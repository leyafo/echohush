// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const assignDiaryTag = `-- name: AssignDiaryTag :one
insert into tags(diary_id, tag) values(?, ?) RETURNING id, diary_id, tag
`

type AssignDiaryTagParams struct {
	DiaryID int64
	Tag     string
}

func (q *Queries) AssignDiaryTag(ctx context.Context, arg AssignDiaryTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, assignDiaryTag, arg.DiaryID, arg.Tag)
	var i Tag
	err := row.Scan(&i.ID, &i.DiaryID, &i.Tag)
	return i, err
}

const getAllDiaries = `-- name: GetAllDiaries :many
select id, entry, created_at, updated_at from diary order by id desc
`

func (q *Queries) GetAllDiaries(ctx context.Context) ([]Diary, error) {
	rows, err := q.db.QueryContext(ctx, getAllDiaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Diary
	for rows.Next() {
		var i Diary
		if err := rows.Scan(
			&i.ID,
			&i.Entry,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDiariesLimit = `-- name: GetAllDiariesLimit :many
select id, entry, created_at, updated_at from diary order by id desc limit ? offset ?
`

type GetAllDiariesLimitParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetAllDiariesLimit(ctx context.Context, arg GetAllDiariesLimitParams) ([]Diary, error) {
	rows, err := q.db.QueryContext(ctx, getAllDiariesLimit, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Diary
	for rows.Next() {
		var i Diary
		if err := rows.Scan(
			&i.ID,
			&i.Entry,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedDiaries = `-- name: GetDeletedDiaries :many
select id, diary_id, diary_entry, diary_created_at, diary_updated_at, created_at from trash order by diary_id desc limit ? offset ?
`

type GetDeletedDiariesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetDeletedDiaries(ctx context.Context, arg GetDeletedDiariesParams) ([]Trash, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedDiaries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trash
	for rows.Next() {
		var i Trash
		if err := rows.Scan(
			&i.ID,
			&i.DiaryID,
			&i.DiaryEntry,
			&i.DiaryCreatedAt,
			&i.DiaryUpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiariesCount = `-- name: GetDiariesCount :one
select count(1) as count from diary
`

func (q *Queries) GetDiariesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDiariesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDiaryByID = `-- name: GetDiaryByID :one
select id, entry, created_at, updated_at from diary where id = ?
`

func (q *Queries) GetDiaryByID(ctx context.Context, id int64) (Diary, error) {
	row := q.db.QueryRowContext(ctx, getDiaryByID, id)
	var i Diary
	err := row.Scan(
		&i.ID,
		&i.Entry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiaryByTag = `-- name: GetDiaryByTag :many
SELECT diary.id, diary.entry, diary.created_at, diary.updated_at FROM diary JOIN tags ON diary.id = tags.diary_id WHERE tags.tag = ? order by diary.id desc limit ? offset ?
`

type GetDiaryByTagParams struct {
	Tag    string
	Limit  int64
	Offset int64
}

func (q *Queries) GetDiaryByTag(ctx context.Context, arg GetDiaryByTagParams) ([]Diary, error) {
	rows, err := q.db.QueryContext(ctx, getDiaryByTag, arg.Tag, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Diary
	for rows.Next() {
		var i Diary
		if err := rows.Scan(
			&i.ID,
			&i.Entry,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoTagDiaries = `-- name: GetNoTagDiaries :many
SELECT diary.id, diary.entry, diary.created_at, diary.updated_at FROM diary LEFT JOIN tags ON diary.id = tags.diary_id WHERE tags.diary_id IS NULL order by diary.id desc limit ? offset ?
`

type GetNoTagDiariesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetNoTagDiaries(ctx context.Context, arg GetNoTagDiariesParams) ([]Diary, error) {
	rows, err := q.db.QueryContext(ctx, getNoTagDiaries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Diary
	for rows.Next() {
		var i Diary
		if err := rows.Scan(
			&i.ID,
			&i.Entry,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDiaryEntry = `-- name: InsertDiaryEntry :one
insert into diary(entry, created_at, updated_at) values(?, ?, ?) RETURNING id, entry, created_at, updated_at
`

type InsertDiaryEntryParams struct {
	Entry     string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) InsertDiaryEntry(ctx context.Context, arg InsertDiaryEntryParams) (Diary, error) {
	row := q.db.QueryRowContext(ctx, insertDiaryEntry, arg.Entry, arg.CreatedAt, arg.UpdatedAt)
	var i Diary
	err := row.Scan(
		&i.ID,
		&i.Entry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertDiaryRecord = `-- name: InsertDiaryRecord :one
insert into diary(entry) values(?) RETURNING id, entry, created_at, updated_at
`

func (q *Queries) InsertDiaryRecord(ctx context.Context, entry string) (Diary, error) {
	row := q.db.QueryRowContext(ctx, insertDiaryRecord, entry)
	var i Diary
	err := row.Scan(
		&i.ID,
		&i.Entry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDiaryEntryByID = `-- name: UpdateDiaryEntryByID :one
UPDATE diary set entry = ?, updated_at=strftime('%s', 'now') where id = ? RETURNING id, entry, created_at, updated_at
`

type UpdateDiaryEntryByIDParams struct {
	Entry string
	ID    int64
}

func (q *Queries) UpdateDiaryEntryByID(ctx context.Context, arg UpdateDiaryEntryByIDParams) (Diary, error) {
	row := q.db.QueryRowContext(ctx, updateDiaryEntryByID, arg.Entry, arg.ID)
	var i Diary
	err := row.Scan(
		&i.ID,
		&i.Entry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
